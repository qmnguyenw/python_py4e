Count the number of common divisors of the given strings



Given two strings **a** and **b** , the task is to count the number of common
divisors of both the strings. A string **s** is a divisor of string **t** if
**t** can be generated by repeating **s** a number of times.

 **Examples:**

>  **Input:** a = “xaxa”, b = “xaxaxaxa”  
>  **Output:** 2  
> The common divisors are “xa” and “xaxa”
>
>  **Input:** a = “bbbb”, b = “bbb”  
>  **Output:** 1  
> The only common divisor is “b”

## Recommended: Please try your approach on **__{IDE}__** first, before moving
on to the solution.

 **Approach:** For a string **s** to be a candidate divisor of string **t** ,
the following conditions must be fulfilled:

  

  

  1.  **s** must be a prefix of **t**.
  2.  **len(t) % len(s) = 0**

Initialize **count = 0** and starting from the first character as the ending
character of the prefix, check whether the length of the prefix divides the
length of both the strings and also if the prefix is same in both the strings.
If **yes** then update **count = count + 1**. Repeat these steps for all the
possible prefixes. Print the value of **count** in the end.

Below is the implementation of the above approach:  

## C++

 __

 __  
 __

 __

 __  
 __  
 __

// C++ implementation of the approach

#include <bits/stdc++.h>

using namespace std;

 

// Function that returns true if sub-string

// s[0...k] is repeated a number of times

// to generate string s

int check(string s, int k)

{

 for (int i = 0; i < s.length(); i++)

 if (s[i] != s[i % k])

 return false;

 

 return true;

}

 

// Function to return the count of common divisors

int countCommonDivisors(string a, string b)

{

 int ct = 0;

 int n = a.size(), m = b.size();

 for (int i = 1; i <= min(n, m); i++) {

 

 // If the length of the sub-string

 // divides length of both the strings

 if (n % i == 0 && m % i == 0)

 

 // If prefixes match in both the strings

 if (a.substr(0, i) == b.substr(0, i))

 

 // If both the strings can be generated

 // by repeating the current prefix

 if (check(a, i) && check(b, i))

 ct++;

 }

 return ct;

}

 

// Driver code

int main()

{

 string a = "xaxa", b = "xaxaxaxa";

 

 cout << countCommonDivisors(a, b);

 

 return 0;

}  
  
---  
  
 __

 __

## Java

 __

 __  
 __

 __

 __  
 __  
 __

// Java implementation of the approach

class GFG 

{

 

 // Function that returns true if sub-string 

 // s[0...k] is repeated a number of times 

 // to generate String s 

 static boolean check(String s, int k)

 {

 for (int i = 0; i < s.length(); i++) 

 {

 if (s.charAt(i) != s.charAt(i % k))

 {

 return false;

 }

 }

 return true;

 }

 

 // Function to return the

 // count of common divisors 

 static int countCommonDivisors(String a, String b) 

 {

 int ct = 0;

 int n = a.length(), m = b.length();

 for (int i = 1; i <= Math.min(n, m); i++) 

 {

 

 // If the length of the sub-string 

 // divides length of both the strings 

 if (n % i == 0 && m % i == 0) 

 {

 // If prefixes match in both the strings

 if (a.substring(0, i).equals(b.substring(0, i))) 

 // by repeating the current prefix 

 {

 // If both the strings can be generated 

 if (check(a, i) && check(b, i)) 

 {

 ct++;

 }

 }

 }

 }

 return ct;

 }

 

 // Driver code 

 public static void main(String[] args) 

 {

 String a = "xaxa", b = "xaxaxaxa";

 System.out.println(countCommonDivisors(a, b));

 }

} 

 

// This code is contributed by PrinciRaj1992  
  
---  
  
 __

 __

## Python3

 __

 __  
 __

 __

 __  
 __  
 __

# Python3 implementation of the above approach

 

# Function that returns true if sub-string 

# s[0...k] is repeated a number of times 

# to generate String s 

def check(s, k):

 

 for i in range (0, len(s)): 

 

 if (s[i] != s[i % k]):

 

 return False

 

 return True

 

# Function to return the

# count of common divisors 

def countCommonDivisors(a, b): 

 

 ct = 0

 n = len(a)

 m = len(b)

 for i in range(1, min(n, m) + 1): 

 

 # If the length of the sub-string 

 # divides length of both the strings 

 if (n % i == 0 and m % i == 0):

 

 # If prefixes match in both the strings

 if (a[0 : i] == b[0 : i]) :

 

 # by repeating the current prefix 

 

 # If both the strings can be generated 

 if (check(a, i) and check(b, i)) :

 

 ct = ct + 1

 

 return ct

 

# Driver code 

a = "xaxa"

b = "xaxaxaxa"

print(countCommonDivisors(a, b))

 

# This code is contributed by ihritik  
  
---  
  
 __

 __

## C#

 __

 __  
 __

 __

 __  
 __  
 __

// C# implementation of the above approach

using System;

 

class GFG 

{

 

// Function that returns true if sub-string 

// s[0...k] is repeated a number of times 

// to generate String s 

static bool check(string s, int k)

{

 for (int i = 0; i < s.Length; i++) 

 {

 if (s[i] != s[i % k])

 {

 return false;

 }

 }

 return true;

}

 

// Function to return the count of

// common divisors 

static int countCommonDivisors(string a, 

 string b) 

{

 int ct = 0;

 int n = a.Length, m = b.Length;

 for (int i = 1; 

 i <= Math.Min(n, m); i++) 

 {

 

 // If the length of the sub-string 

 // divides length of both the strings 

 if (n % i == 0 && m % i == 0) 

 {

 // If prefixes match in both the strings

 if (a.Substring(0, i) == (b.Substring(0, i))) 

 

 // by repeating the current prefix 

 {

 // If both the strings can be generated 

 if (check(a, i) && check(b, i)) 

 {

 ct++;

 }

 }

 }

 }

 return ct;

}

 

// Driver code 

public static void Main() 

{

 string a = "xaxa", b = "xaxaxaxa";

 Console.WriteLine(countCommonDivisors(a, b));

}

} 

 

// This code is contributed by ihritik  
  
---  
  
 __

 __

 **Output:**

    
    
    2
    

Attention reader! Don’t stop learning now. Get hold of all the important DSA
concepts with the **DSA Self Paced Course** at a student-friendly price and
become industry ready. To complete your preparation from learning a language
to DS Algo and many more, please refer **Complete Interview Preparation
Course** **.**

My Personal Notes _arrow_drop_up_

Save

